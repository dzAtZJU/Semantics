'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * TODO: Determine if the shape of an error response is specific to each service or widely used
 */
class MongoDBRealmError extends Error {
    constructor(method, url, statusCode, statusText, response) {
        if (typeof response === "object" &&
            typeof response.error === "string") {
            const statusSummary = statusText
                ? `status ${statusCode} ${statusText}`
                : `status ${statusCode}`;
            super(`Request failed (${method} ${url}): ${response.error} (${statusSummary})`);
            this.method = method;
            this.url = url;
            this.statusText = statusText;
            this.statusCode = statusCode;
            this.errorCode = response.error_code;
            this.link = response.link;
        }
        else {
            throw new Error("Unexpected error response format");
        }
    }
}

////////////////////////////////////////////////////////////////////////////
const isNodeProcess = typeof process === "object";
class DefaultNetworkTransport {
    constructor() {
        // Determine the fetch implementation
        if (!DefaultNetworkTransport.fetch) {
            // Try to get it from the global
            if (typeof window === "object" &&
                typeof window.fetch === "function") {
                DefaultNetworkTransport.fetch = window.fetch.bind(window);
            }
            else if (isNodeProcess && typeof require === "function") {
                // Making it harder for the static analyzers see this require call
                const nodeRequire = require;
                DefaultNetworkTransport.fetch = nodeRequire("node-fetch");
            }
            else {
                throw new Error("DefaultNetworkTransport.fetch must be set before it's used");
            }
        }
        // Determine the AbortController implementation
        if (!DefaultNetworkTransport.AbortController) {
            if (typeof window === "object" && window.AbortController) {
                DefaultNetworkTransport.AbortController =
                    window.AbortController;
            }
            else if (isNodeProcess && typeof require === "function") {
                // Making it harder for the static analyzers see this require call
                const nodeRequire = require;
                DefaultNetworkTransport.AbortController = nodeRequire("abort-controller");
            }
            else {
                throw new Error("DefaultNetworkTransport.AbortController must be set before it's used");
            }
        }
    }
    fetchAndParse(request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.fetch(request);
                const contentType = response.headers.get("content-type");
                if (response.ok) {
                    if (contentType === null) {
                        return null;
                    }
                    else if (contentType.startsWith("application/json")) {
                        // Awaiting the response to ensure we'll throw our own error
                        return yield response.json();
                    }
                    else {
                        throw new Error("Expected an empty or a JSON response");
                    }
                }
                else if (contentType &&
                    contentType.startsWith("application/json")) {
                    throw new MongoDBRealmError(request.method, request.url, response.status, response.statusText, yield response.json());
                }
                else {
                    throw new Error(`Unexpected status code (${response.status} ${response.statusText})`);
                }
            }
            catch (err) {
                if (err instanceof MongoDBRealmError) {
                    throw err;
                }
                else {
                    throw new Error(`Request failed (${request.method} ${request.url}): ${err.message}`);
                }
            }
        });
    }
    fetchWithCallbacks(request, handler) {
        // tslint:disable-next-line: no-console
        this.fetch(request)
            .then((response) => __awaiter(this, void 0, void 0, function* () {
            const decodedBody = yield response.text();
            // Pull out the headers of the response
            const responseHeaders = {};
            response.headers.forEach((value, key) => {
                responseHeaders[key] = value;
            });
            return {
                statusCode: response.status,
                headers: responseHeaders,
                body: decodedBody,
            };
        }))
            .then(r => handler.onSuccess(r))
            .catch(e => handler.onError(e));
    }
    fetch(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const { method, url, body, timeoutMs, headers = DefaultNetworkTransport.DEFAULT_HEADERS, } = request;
            const { signal, cancelTimeout } = this.createTimeoutSignal(timeoutMs);
            try {
                // We'll await the response to catch throw our own error
                return yield DefaultNetworkTransport.fetch(url, {
                    method,
                    headers,
                    body: typeof body === "string" ? body : JSON.stringify(body),
                    signal,
                });
            }
            finally {
                // Whatever happens, cancel any timeout
                cancelTimeout();
            }
        });
    }
    createTimeoutSignal(timeoutMs) {
        if (typeof timeoutMs === "number") {
            const controller = new DefaultNetworkTransport.AbortController();
            // Call abort after a specific number of milliseconds
            const timeout = setTimeout(() => {
                controller.abort();
            }, timeoutMs);
            return {
                signal: controller.signal,
                cancelTimeout: () => {
                    clearTimeout(timeout);
                },
            };
        }
        else {
            return {
                signal: undefined,
                cancelTimeout: () => {
                    /* No-op */
                },
            };
        }
    }
}
DefaultNetworkTransport.DEFAULT_HEADERS = {
    Accept: "application/json",
    "Content-Type": "application/json",
};

exports.DefaultNetworkTransport = DefaultNetworkTransport;
exports.MongoDBRealmError = MongoDBRealmError;
